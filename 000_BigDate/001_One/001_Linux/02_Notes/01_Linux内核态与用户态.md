# Linux内核态与用户态

## 1. 概念及对比

| 类别             | 内核态                                                       | 用户态                                                       |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 概念             | 一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于内核运行态（内核态）。 | 进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。 |
| 处理器处于特权级 | 0级                                                          | 3级                                                          |

## 2. 相关概念

### 2.1 特权级

+ 特权级是有效管理和控制程序执行的手段和方式。
+ 最关键性的权力必须由高特权级的程序来执行，这样才可以做到集中管理，减少有限资源的访问和使用冲突。比如对进程的创建，其需要综合系统的物理资源、分配物理内存以及各种信息的处理，显然不能让随便一个程序去执行。
+ intel x86架构的CPU一共有0~3四个特权级，0级最高，3级最低。
+ `Unix/Linux，只使用了0级特权级和3级特权级。`
+ 在Unix/Linux系统中，一条工作在0级特权级的指令具有了CPU能提供的最高权力，而一条工作在3级特权级的指令具有CPU提供的最低或者说最基本权力。
+ 等同于权限，权力的不同。
  + 运行在用户态下的程序不能直接访问操作系统内核数据结构和程序，比如用户自己编写的方法testfork()就不能直接调用sys_fork()，因为前者是工作在用户态，属于用户态程序，而sys_fork()是工作在内核态，属于内核态程序。
  + 当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态，比如testfork()最初运行在用户态进程下，当它调用fork()最终触发sys_fork()的执行时，就切换到了内核态（即系统调用）。

## 3.相互转换

三种方式。

具体操作：

+ 从触发方式上看，可以认为存在前述3种不同的类型，但是从最终实际完成由用户态到内核态的切换操作上来说，涉及的关键步骤是完全一致的，没有任何区别，都相当于执行了一个中断响应的过程，因为系统调用实际上最终是中断机制实现的，而异常和中断的处理机制基本上也是一致的，关于它们的具体区别这里不再赘述。关于中断处理机制的细节和步骤这里也不做过多分析，涉及到由用户态切换到内核态的步骤主要包括：
  + 从当前进程的描述符中提取其内核栈的ss0（存放栈的段地址）及esp0（栈指针，用于指向栈的栈顶）信息。
  + 使用ss0和esp0指向的内核栈将当前进程的`cs,eip,eflags,ss,esp`信息保存起来，这个过程也完成了由用户栈到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令。
  + 将先前由中断向量检索得到的中断处理程序的cs（代码段寄存器）,eip（存储着我们cpu要读取指令的地址）信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了。

### 3.1 系统调用

+ 用户主动发起
+ 用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如创建子进程的函数`fork()`实际上就是执行了一个创建新进程的系统调用。
+ 而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。

### 3.2 异常

+ 用户被动发起
+ 当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。

### 3.3 外围设备的中断

+ 用户被动发起
+ 当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。